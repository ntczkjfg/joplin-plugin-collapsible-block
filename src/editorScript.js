import { Decoration, ViewPlugin } from '@codemirror/view';
import { RangeSetBuilder } from '@codemirror/state';

export default (context) => {
    return {
        assets: () => [{ name: 'style.css' }],
        plugin: async (codeMirrorWrapper) => {
            const settings = await context.postMessage({ name: 'getSettings', data: {} });
            const { doEditorColors, startToken, endToken, indentLevel, maxIndentLevel } = settings;

            // Dynamically build CSS for indentation based on user settings
            let css = `/* Dynamically generated by Collapsible Blocks plugin */\n`;;
            for (let i = 1; i <= maxIndentLevel; i++) {
                css += `
                    .cb-indent-${i} {
                        margin-left: ${i*indentLevel/10.0}em;
                    }
                `
            } // The settings page lies when it says indentLevel is unitless - it's actually in units of â…’ em
            // Inject CSS into document head dynamically
            // existingCSS will already be defined if the plugin was loaded before now
            let existingCSS = document.getElementById('cb-dynamic-css');
            if (existingCSS) {
                // Modifying the existing CSS like this allows it to update after changing settings without restarting Joplin
                existingCSS.textContent = css;
            } else {
                const style = document.createElement('style');
                style.type = 'text/css';
                style.id = 'cb-dynamic-css';
                style.textContent = css.trim();
                document.head.appendChild(style);
            }

            // Defines a CodeMirror view plugin that updates decorations on relevant changes
            const collapsibleEditorColorsPlugin = ViewPlugin.fromClass(
                class {
                    constructor(view) {
                        try {
                            this.decorations = findCollapsibles(view);
                        } catch (e) {
                            console.error('Error in line parsing:', e);
                        }
                    }
                    update(update) {
                        if (update.docChanged || update.viewportChanged) {
                            try {
                                this.decorations = findCollapsibles(update.view);
                            } catch (e) {
                                console.error('Error in line parsing:', e);
                            }
                        }
                    }
                },
                {
                decorations: v => v.decorations
                }
            );

            function processLines(doc) {
                let docLines = [''];
                for (let i = 1, line; i <= doc.lines; i++) { // Yes it indexes from 1
                    line = doc.line(i).text;
                    // Remove leading spaces and tabs
                    line = line.replace(/^[ \t]+/, "");
                    docLines.push(line)
                    // Note that docLines is now also indexed from 1 - its initial entry was a dummy
                }
                // levels contains ${doc.lines+1} entries of the form [i, 0, 0]
                // i is the line number, from 1 to doc.lines (First entry is a dummy so we index from 1)
                // The first 0 will hold the nesting level of each line in time
                // The second 0 will hold the indentation level of each line in time
                // We are indexing from 0 (to match doc.lines) so levels[0] is just an unused placeholder
                let levels = Array.from({ length: doc.lines + 1 }, (_, i) => [i, 0, 0]);
                for (let i = 1; i < docLines.length; i++) {
                    if (!docLines[i].startsWith(startToken)) {
                        // Not the start of a block, make no changes to levels
                        continue;
                    }
                    // This line starts with our startToken
                    levels[i][1] += 1;
                    if (docLines[i].endsWith(endToken)) {
                        // And also ends with it - it's a valid block spanning only this line
                        // Since it's an entire block we indent it, even though it's the title line too
                        continue;
                    }
                    // Look for the matching endToken
                    let endLine;
                    for (let j = i + 1, nestedBlocks = 0; j < docLines.length; j++) {
                        if (docLines[j].startsWith(startToken)) {
                            nestedBlocks++;
                        }
                        if (docLines[j].endsWith(endToken)) {
                            if (nestedBlocks === 0) {
                                endLine = j;
                                break;
                            }
                            nestedBlocks--;
                        }
                    }
                    if (endLine) {
                        // If we're in here, it's a valid block - let's increase nesting and indent levels
                        // Skip line i, for aesthetics we don't indent the title line, and it's already had
                        // its nesting level adjusted above
                        for (let j = i+1; j <= endLine; j++) {
                            levels[j][1] += 1;
                            levels[j][2] += 1;
                        }
                        // If the endToken is on its own line, we de-dent it (to the same level as the title)
                        // This is purely for aesthetic reasons
                        if (docLines[endLine] === endToken || docLines[endLine] === endToken + endToken) {
                            levels[endLine][2] -= 1;
                        }
                    }
                }
                // Remove entries from levels that are not part of any collapsible block
                levels = levels.filter(([i, nestLevel, indentLevel]) => !(nestLevel === 0 && indentLevel === 0));
                return levels;
            }

            // Finds valid collapsible blocks in the editor, marks which lines in the editor are part of these blocks
            function findCollapsibles(view) {
                // lines will contain every line number that is part of a collapsible block
                // lines which are in nested blocks will appear multiple times - this is desired
                const builder = new RangeSetBuilder();
                const doc = view.state.doc;
                const lines = processLines(doc);
                if (lines.length === 0) {
                    // No collapsible blocks to process
                    return builder.finish();
                }
                for (let i = 0; i < lines.length; i++) {
                    let [lineNum, nestLevel, indentLevel] = lines[i];
                    // We only support 8 colors, so nestLevel goes from 0-7 then repeats
                    nestLevel = (nestLevel - 1) % 8;
                    indentLevel = Math.min(indentLevel, maxIndentLevel);
                    const from = view.state.doc.line(lineNum).from;
                    let classes = 'cb';
                    if (doEditorColors) {
                        classes += ` cb-nest-${nestLevel}`;
                    }
                    if (indentLevel) {
                        classes += ` cb-indent-${indentLevel}`;
                    }
                    builder.add(from, from, Decoration.line({ class: classes }));
                }
                return builder.finish();
            }

            // Add the extension
            codeMirrorWrapper.addExtension(collapsibleEditorColorsPlugin);
        }
    };
};