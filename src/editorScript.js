import { Decoration, ViewPlugin, DecorationSet, EditorView, WidgetType } from '@codemirror/view';
import { RangeSetBuilder, EditorState } from '@codemirror/state';
import { codeFolding, foldEffect, unfoldEffect, foldedRanges } from "@codemirror/language";

export default (context) => {
    return {
        plugin: async function(CodeMirror) {
            const settings = await context.postMessage({ name: 'getSettings', data: {} });
            const { doEditorColors, startToken, endToken, indentLevel,
                maxIndentLevel, collapsibleInEditor,
                lockEditorAndWebview, darkMode, rememberOpenOrClose,
                headingsCollapsibleEditor } = settings;
            // Add codeFolding (with no placeholder) and our foldPlugin
            CodeMirror.addExtension(codeFolding({
                placeholderDOM: () => document.createElement('span')
            }));
            CodeMirror.addExtension(foldPlugin(
                settings, context.postMessage
            ));
            // Add the editor colors extension
            CodeMirror.addExtension(collapsibleEditorColorsPlugin(
                settings
            ));

            // Dynamically build CSS for indentation based on user settings
            // We do this here instead of in assets because it allows us to update
            // the CSS when the plugin settings change, without restarting Joplin
            let css = `/* Dynamically generated by Collapsible Blocks plugin */\n`;
            for (let i = 1; i <= settings.maxIndentLevel; i++) {
                css += `
                    .cb-indent-${i} {
                        margin-left: ${i * settings.indentLevel / 10.0}em;
                    }`;
            } // The settings page lies when it says indentLevel is unitless - it's actually in units of ⅒ em
            // Inject CSS into document head dynamically
            // existingCSS will already be defined if the plugin was loaded before now
            let existingCSS = document.getElementById('cb-dynamic-css');
            if (existingCSS) {
                // Modifying the existing CSS like this allows it to update after changing settings without restarting Joplin
                existingCSS.textContent = css;
            } else {
                const style = document.createElement('style');
                style.type = 'text/css';
                style.id = 'cb-dynamic-css';
                style.textContent = css.trim();
                document.head.appendChild(style);
            }
        },
        assets: () => { return [ { name: 'style.css' } ]; }
    };
};

/*

COLLAPSIBLES IN THE EDITOR PLUGIN

*/

class FoldWidget extends WidgetType {
    constructor(id, isFolded, startFrom, startTo, foldFrom, foldTo, endTo, doUpdate, postMessage, settings, heading) {
        super();
        this.id = id;
        this.isFolded = isFolded;
        this.startFrom = startFrom;
        this.startTo = startTo;
        this.foldFrom = foldFrom;
        this.foldTo = foldTo;
        this.endTo = endTo;
        this.doUpdate = doUpdate;
        this.postMessage = postMessage;
        this.settings = settings;
        this.heading = heading ?? false;
    }

    eq(other) {
        return other instanceof FoldWidget &&
            (other.id === this.id ||
            (other.foldFrom === this.foldFrom &&
            other.foldTo === this.foldTo))
    }

    toDOM(view) {
        if ((!this.heading && !this.settings.collapsibleInEditor) || (this.heading && !this.settings.headingsCollapsibleEditor)) {
            return document.createElement('span');
        }
        const span = document.createElement('span');
        span.className = 'cm-fold-toggle';
        span.textContent = this.isFolded ? ' ▶ ' : ' ▼ ';
        span.style.cursor = 'pointer';
        span.onclick = span.ontouchstart = () => {
            this.postMessage({ name: 'error', data: { 'error': 'CLICKED!' } });
            this.postMessage({ name: 'error', data: { 'error': `isFolded = ${this.isFolded}` } });
            this.postMessage({ name: 'collapsibleToggle', data: { id: this.id, isFolded: !this.isFolded } }).then(() => {
                view.dispatch({ changes: [{ from: 0, to: 0, insert: '' }] });
            });
        };
        this.span = span;
        return span;
    }

    ignoreEvent() {
        return true;
    }
}

const foldPlugin = (settings, postMessage) => ViewPlugin.fromClass(
    class {
        constructor(view) {
            try {
                this.currentNoteLength = view.state.doc.length; // Helps detect when the note changes
                this.foldWidgets = {};
                this.collapsibleList = {};
                this.update(undefined, view);
            } catch (e) {
                console.error('Error in fold plugin constructor:', e);
                this.decorations = Decoration.none;
            }
        }

        async update(update, view) {
            try {
                if (view || update.docChanged || update.viewportChanged) {
                    postMessage({ name: 'error', data: { 'error': 'Regular update!' } });
                    const newNote = this.noteChanged(update);
                    if (newNote || view) {
                        view = view ?? update.view;
                        //this.decorations = Decoration.none;
                        this.collapsibleList = {};
                        // index.ts detects this event on its own, no need to post it a message
                        this.foldWidgets = {};
                        this.decorations = this.buildDecorations(view, true);
                        this.collapsibleList = await postMessage({ name: 'fixList', data: { 'collapsibleList': this.collapsibleList } });
                        this.decorations = this.buildDecorations(view, true);
                    } else {
                        this.updateFoldWidgetPositions(update);
                        this.decorations = this.buildDecorations(update.view, false);
                    }
                } else if (foldedRanges(update.startState) !== foldedRanges(update.state)) {
                    return;
                    this.decorations = this.buildDecorations(update.view, false);
                } else if (update.transactions.some(tr => tr.annotations.some(annotation => annotation.value === 'input.type.compose'))) {
                    postMessage({ name: 'error', data: { 'error': 'Special update!' } });
                    this.collapsibleList = await postMessage({ name: 'getList', data: {} });
                    this.decorations = this.buildDecorations(update.view, false);
                }
            } catch (e) {
                console.error('Error in fold plugin update:', e);
                this.decorations = Decoration.none;
            }
        }

        updateFoldWidgetPositions(update) {
            update.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
                const delta = inserted.length - (toA - fromA);

                for (const id of Object.keys(this.foldWidgets)) {
                    const foldWidget = this.foldWidgets[id];

                    if (fromA < foldWidget.startFrom) {
                        if (toA <= foldWidget.startTo) {
                            foldWidget.startFrom += delta;
                            foldWidget.endTo     += delta;
                            this.collapsibleList[id].lineNum = update.view.state.doc.lineAt(foldWidget.startFrom).number;
                            continue;
                        } else {
                            delete this.foldWidgets[id];
                            if (id in this.collapsibleList) delete this.collapsibleList[id];
                            continue;
                        }
                    } else if (fromA === foldWidget.startFrom) {
                        if (toA <= foldWidget.endTo) {
                            foldWidget.endTo += delta;
                            continue;
                        } else {
                            delete this.foldWidgets[id];
                            if (id in this.collapsibleList) delete this.collapsibleList[id];
                            continue;
                        }
                    } else if (fromA < foldWidget.endTo) {
                        if (toA <= foldWidget.endTo) {
                            foldWidget.endTo += delta;
                            continue;
                        } else {
                            delete this.foldWidgets[id];
                            if (id in this.collapsibleList) delete this.collapsibleList[id];
                            continue;
                        }
                    }
                }
            });
            postMessage({ name: 'setList', data: { collapsibleList: this.collapsibleList } });
        }

        toggleWidget(view, foldWidget) {
            postMessage({ name: 'error', data: { 'error': 'toggleWidget' } });
            let effects = { effects: [], changes: [] };
            const { startToken } = settings;

            const line = view.state.doc.lineAt(foldWidget.startFrom);
            const lineText = line.text.replace(/^[ \t]+/, "");
            let foldFrom = foldWidget.foldFrom;
            let foldTo = foldWidget.foldTo;
            if (!foldWidget.heading && foldWidget.doUpdate && (settings.lockEditorAndWebview || settings.rememberOpenOrClose)) {
                const from = line.from + line.text.indexOf(startToken);
                if (foldWidget.isFolded) {
                    if (!lineText.startsWith(startToken + startToken)) {
                        effects.changes = [{
                            from: from,
                            to: from,
                            insert: startToken,
                        }];
                        foldFrom += startToken.length;
                        foldTo += startToken.length;
                    }
                } else {
                    if (lineText.startsWith(startToken + startToken)) {
                        effects.changes = [{
                            from: from,
                            to: from + startToken.length,
                            insert: '',
                        }];
                        foldFrom -= startToken.length;
                        foldTo -= startToken.length
                    }
                }
            }
            if ((!foldWidget.heading && settings.collapsibleInEditor) || (foldWidget.heading && settings.headingsCollapsibleEditor)) {
                if (foldWidget.isFolded) {
                    postMessage({ name: 'error', data: { 'error': 'unfolding!' } });
                    effects.effects = [
                        unfoldEffect.of({
                            from: foldFrom,
                            to: foldTo,
                        })
                    ];
                } else {
                    postMessage({ name: 'error', data: { 'error': 'folding!' } });
                    effects.effects = [
                        foldEffect.of({
                            from: foldFrom,
                            to: foldTo,
                        })
                    ];
                }
            }
            foldWidget.isFolded = !foldWidget.isFolded;
            if (foldWidget.span) foldWidget.span.textContent = foldWidget.isFolded ? ' ▶ ' : ' ▼ ';
            return effects;
        }

        updateFoldWidgets(view) {
            postMessage({ name: 'error', data: { 'error': 'updateFoldWidgets' } });
            const effects = { effects: [], changes: [] };
            for (const foldWidget of Object.values(this.foldWidgets)) {
                if (this.collapsibleList[foldWidget.id].isFolded != foldWidget.isFolded) {
                    const newEffects = this.toggleWidget(view, foldWidget);
                    effects.effects = [...effects.effects, ...newEffects.effects];
                    effects.changes = [...effects.changes, ...newEffects.changes];
                }
            }
            setTimeout(() => { view.dispatch( effects ) }, 0);
        }

        // Detects, synchronously, if the user changed notes
        noteChanged(update) {
            if (!update) return false;
            let noteChanged = false;
            update.changes.iterChanges( (fromA, toA, fromB, toB, inserted) => {
                if (
                    fromA === 0 && toA === this.currentNoteLength &&
                    fromB === 0 && toB === update.view.state.doc.length) {
                    noteChanged = true;
                }
            });
            // The above condition always happens on note changed - can have false positives too though
            // For example, would trigger if the user replaced the entire note at once
            this.currentNoteLength = update.view.state.doc.length;
            return noteChanged;
        }

        buildDecorations(view, initial) {
            postMessage({ name: 'error', data: { 'error': 'buildDecorations' } });
            // This function must run even if collapsibles are NOT collapsible in the editor
            // This is so FoldWidgets and their associated ids still get created
            // These are used to make the behavior of collapsibles in the webview more reliable
            const builder = [];
            const regions = this.processLines(view.state.doc);
            const folded = foldedRanges(view.state);
            const effects = [];
            for (const id of Object.keys(this.foldWidgets)) {
                const foldWidget = this.foldWidgets[id];
                let del = true;
                for (const region of regions) {
                    if (foldWidget.startFrom === region.startFrom && foldWidget.endTo === region.endTo) {
                        foldWidget.startTo = region.startTo;
                        foldWidget.foldFrom = region.foldFrom;
                        foldWidget.foldTo = region.foldTo;
                        foldWidget.doUpdate = region.doUpdate;
                        del = false;
                        break;
                    }
                }
                if (del) {
                    //console.error('DELETING WIDGET!');
                    effects.push(unfoldEffect.of({ from: foldWidget.foldFrom, to: foldWidget.foldTo }));
                    delete this.foldWidgets[id];
                    if (id in this.collapsibleList) delete this.collapsibleList[id];
                }
            }
            for (const region of regions) {
                // Determine if this region is folded or unfolded in the editor
                let isFolded = false;
                if ((!region.heading && settings.collapsibleInEditor) || (region.heading && settings.headingsCollapsibleEditor)) {
                    // Will iterate over all folded regions in the editor which intersect the interval [region.foldFrom, region.foldTo]
                    // Exits iteration early if false returned
                    folded.between(region.foldFrom, region.foldTo, (foldedFrom, foldedTo, foldedValue) => {
                        if (foldedFrom === region.foldFrom && foldedTo === region.foldTo) {
                            isFolded = true;
                            return false;
                        }
                    });
                } else {
                    const line = view.state.doc.lineAt(region.startFrom);
                    const lineText = line.text.replace(/^[ \t]+/, "");
                    isFolded = !lineText.startsWith(settings.startToken + settings.startToken);
                }

                let widget;
                for (const foldWidget of Object.values(this.foldWidgets)) {
                    if (foldWidget.foldFrom === region.foldFrom && foldWidget.foldTo === region.foldTo) {
                        foldWidget.isFolded = isFolded;
                        widget = foldWidget;
                        break;
                    }
                }
                if (widget === undefined) {
                    widget = new FoldWidget(Math.random().toString(36).slice(2), // id
                                            initial ? region.isFolded : isFolded,
                                            region.startFrom,
                                            region.startTo,
                                            region.foldFrom,
                                            region.foldTo,
                                            region.endTo,
                                            region.doUpdate,
                                            postMessage,
                                            settings,
                                            region.heading
                                            );
                    this.foldWidgets[widget.id] = widget;
                }
                if (widget.id in this.collapsibleList) {
                    this.collapsibleList[widget.id].lineNum = region.lineNum;
                    this.collapsibleList[widget.id].doUpdate = region.doUpdate;
                    widget.doUpdate = region.doUpdate;
                } else {
                    this.collapsibleList[widget.id] = { id: widget.id,
                                                        doUpdate: region.doUpdate,
                                                        isFolded: initial ? region.isFolded : isFolded,
                                                        lineNum: region.lineNum,
                                                        webviewFolded: region.isFolded,
                                                        heading: region.heading };
                }
                const deco = Decoration.widget({ widget }).range(region.foldFrom);
                if (initial &&
                    region.isFolded &&
                    ((!widget.heading && settings.collapsibleInEditor) || (widget.heading && settings.headingsCollapsibleEditor)) &&
                    settings.lockEditorAndWebview) {
                    effects.push(foldEffect.of({ from: region.foldFrom, to: region.foldTo }));
                    widget.isFolded = true;
                }

                builder.push(deco);
            }
            postMessage({ name: 'setList', data: { collapsibleList: this.collapsibleList } });
            if (settings.collapsibleInEditor || settings.headingsCollapsibleEditor || settings.rememberOpenOrClose) {
                this.updateFoldWidgets(view);
            }
            if (effects) setTimeout(() => {view.dispatch({ effects: effects });}, 0);
            return Decoration.set(builder, true);
        }

        processLines(doc) {
            const { startToken, endToken } = settings;
            const regions = [];
            let inCodeBlock = false;
            let codeBlockChar = '';
            let codeBlockLen = 0;
            const headings = [];
            // Below are unused for now but planning to use later
            function escapeForRegex(str) { return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
            const startTokenRegex = new RegExp('^[ \t]*((?:' + escapeForRegex(startToken) + '){1,2})');
            let match;

            for (let i = 1; i < doc.lines; i++) { // doc.lines indexes from 1
                const line = doc.line(i).text;
                if (!inCodeBlock) {
                    match = line.match(/^ {0,3}([`~]{3,})/);
                    if (match) {
                        inCodeBlock = true;
                        codeBlockChar = match[1][0];
                        codeBlockLen = match[1].length;
                        continue;
                    }
                } else {
                    match = line.match(new RegExp(`^ {0,3}${codeBlockChar}{${codeBlockLen},}$`));
                    if (match) {
                        inCodeBlock = false;
                        codeBlockChar = '';
                        codeBlockLen = 0;
                    }
                    continue;
                }

                // Headings! Starts with 0-3 spaces, then 1-6 #s, then a space or tab then anything else - can also end immediately after the #s
                match = line.match(/^ {0,3}(#{1,6})([ \t](.*?)$|$)/);
                if (match) {
                    const heading = {
                        line: i,
                        order: match[1].length,
                        from: doc.line(i).from,
                        to: doc.line(i).to,
                    };
                    headings.push(heading);
                    continue;
                }

                // Start looking for user-defined collapsible blocks now
                match = line.match(startTokenRegex);
                if (!match) continue; // Not the start of a block, make no changes to levels

                const isFolded = match[1].length !== 2*startToken.length; // Start token is doubled
                // This line starts with our startToken
                if (line.endsWith(endToken)) continue; // And ends with it - nothing to collapse
                // Look for the matching endToken
                let endLine;
                let endTokenLen;
                for (let j = i + 1, nestedBlocks = 0; j < doc.lines; j++) {
                    const lineJ = doc.line(j).text;
                    if (startTokenRegex.test(lineJ)) {
                        nestedBlocks++;
                    }
                    if (lineJ.endsWith(endToken)) {
                        if (nestedBlocks === 0) {
                            endLine = j;

                            if (lineJ.endsWith(endToken + endToken)) endTokenLen = 2 * endToken.length;
                            else endTokenLen = endToken.length
                            break;
                        }
                        nestedBlocks--;
                    }
                }
                if (endLine) {
                    const startFrom = doc.line(i).from + line.indexOf(startToken);
                    const startTo = startFrom + (isFolded ? startToken.length : 2*startToken.length);
                    regions.push({
                        isFolded: isFolded,
                        startFrom: startFrom,
                        startTo: startTo,
                        foldFrom: doc.line(i).to,
                        foldTo: doc.line(endLine).to - endTokenLen,
                        endTo: doc.line(endLine).to,
                        doUpdate: endTokenLen === endToken.length,
                        lineNum: i - 1,
                    });
                }
            }
            // Add the headings to regions now that we have all of them
            for (const heading of headings) {
                const region = {
                    isFolded: false,
                    startFrom: heading.from,
                    startTo: heading.to,
                    foldFrom: heading.to,
                    doUpdate: false,
                    lineNum: heading.line,
                    heading: true,
                };
                // Find next heading of equal or higher precedence
                let nextHeading = null;
                for (const candidate of headings) {
                    if (candidate.line > heading.line && candidate.order <= heading.order) {
                        nextHeading = candidate;
                        break;
                    }
                }
                if (nextHeading) {
                    region.foldTo = nextHeading.from - 1;
                    region.endTo = nextHeading.from - 1;
                } else {
                    region.foldTo = doc.length;
                    region.endTo = doc.length;
                }
                regions.push(region);
            }
            return regions;
        }
    },
    {
        decorations: v => v.decorations,
    }
);











/*

EDITOR COLORS PLUGIN

*/

// Defines a CodeMirror view plugin that updates decorations on relevant changes
const collapsibleEditorColorsPlugin = (settings) => ViewPlugin.fromClass(
    class {
        constructor(view) {
            try {
                this.decorations = this.findCollapsibles(view);
            } catch (e) {
                console.error('Error in color plugin constructor:', e);
            }
        }
        update(update) {
            if (update.docChanged || update.viewportChanged) {
                try {
                    this.decorations = this.findCollapsibles(update.view);
                } catch (e) {
                    console.error('Error in color plugin update:', e);
                }
            }
        }

        processLines(doc) {
            const { startToken, endToken } = settings;
            let docLines = [''];
            for (let i = 1, line; i <= doc.lines; i++) { // Yes it indexes from 1
                line = doc.line(i).text;
                // Remove leading spaces and tabs
                line = line.replace(/^[ \t]+/, "");
                docLines.push(line)
                // Note that docLines is now also indexed from 1 - its initial entry was a dummy
            }
            // levels contains ${doc.lines+1} entries of the form [i, 0, 0]
            // i is the line number, from 1 to doc.lines (First entry is a dummy so we index from 1)
            // The first 0 will hold the nesting level of each line in time
            // The second 0 will hold the indentation level of each line in time
            // We are indexing from 1 (to match doc.lines) so levels[0] is just an unused placeholder
            let levels = Array.from({ length: doc.lines + 1 }, (_, i) => [i, 0, 0]);
            let inCodeBlock = false;
            let codeBlockChar = '';
            let codeBlockLen = 0;
            for (let i = 1; i < docLines.length; i++) {
                if (!inCodeBlock) {
                    let match = docLines[i].match(/^ {0,3}([`~]{3,})/);
                    if (match) {
                        inCodeBlock = true;
                        codeBlockChar = match[1][0];
                        codeBlockLen = match[1].length;
                        continue;
                    }
                } else {
                    let match = docLines[i].match(new RegExp(`^ {0,3}${codeBlockChar}{${codeBlockLen},}$`));
                    if (match) {
                        inCodeBlock = false;
                        codeBlockChar = '';
                        codeBlockLen = 0;
                    }
                    continue;
                }
                if (!docLines[i].startsWith(startToken)) {
                    // Not the start of a block, make no changes to levels
                    continue;
                }
                // This line starts with our startToken
                levels[i][1] += 1;
                if (docLines[i].endsWith(endToken)) {
                    // And also ends with it - it's a valid block spanning only this line
                    // Since it's an entire block we indent it, even though it's the title line too
                    continue;
                }
                // Look for the matching endToken
                let endLine;
                for (let j = i + 1, nestedBlocks = 0; j < docLines.length; j++) {
                    if (docLines[j].startsWith(startToken)) {
                        nestedBlocks++;
                    }
                    if (docLines[j].endsWith(endToken)) {
                        if (nestedBlocks === 0) {
                            endLine = j;
                            break;
                        }
                        nestedBlocks--;
                    }
                }
                if (endLine) {
                    // If we're in here, it's a valid block - let's increase nesting and indent levels
                    // Skip line i, for aesthetics we don't indent the title line, and it's already had
                    // its nesting level adjusted above
                    for (let j = i+1; j <= endLine; j++) {
                        levels[j][1] += 1;
                        levels[j][2] += 1;
                    }
                    // If the endToken is on its own line, we de-dent it (to the same level as the title)
                    // This is purely for aesthetic reasons
                    if (docLines[endLine] === endToken || docLines[endLine] === endToken + endToken) {
                        levels[endLine][2] -= 1;
                    }
                } else levels[i][1] = 0;
            }
            // Remove entries from levels that are not part of any collapsible block
            levels = levels.filter(([i, nestLevel, indentLevel]) => !(nestLevel === 0 && indentLevel === 0));
            return levels;
        }

        // Finds valid collapsible blocks in the editor, marks which lines in the editor are part of these blocks
        findCollapsibles(view) {
            // lines will contain every line number that is part of a collapsible block
            // lines which are in nested blocks will appear multiple times - this is desired
            const builder = new RangeSetBuilder();
            const doc = view.state.doc;
            const lines = this.processLines(doc);
            if (lines.length === 0) {
                // No collapsible blocks to process
                return builder.finish();
            }
            for (let i = 0; i < lines.length; i++) {
                let [lineNum, nestLevel, indentLevel] = lines[i];
                // We only support 8 colors, so nestLevel goes from 0-7 then repeats
                nestLevel = (nestLevel - 1) % 8;
                indentLevel = Math.min(indentLevel, settings.maxIndentLevel);
                const from = view.state.doc.line(lineNum).from;
                let classes = 'cb';
                if (settings.darkMode) classes += ' cb-dark';
                else classes += ' cb-light';
                if (settings.doEditorColors) {
                    classes += ` cb-nest-${nestLevel}`;
                }
                if (indentLevel) {
                    classes += ` cb-indent-${indentLevel}`;
                }
                builder.add(from, from, Decoration.line({ class: classes }));
            }
            return builder.finish();
        }
    },
    {
        decorations: v => v.decorations
    }
);